<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Sweet Trip Planner üç¨</title>

  <!-- Leaflet CSS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <!-- OpenCage Autocomplete CSS -->
  <link rel="stylesheet" href="https://unpkg.com/@opencage/autocomplete-js/dist/css/autocomplete.min.css" />

  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 20px;
      background: #fdf6f9;
      color: #333;
      transition: all 0.3s ease;
    }
    h1 {
      color: #d63384;
    }
    form {
      margin-bottom: 20px;
    }
    #map {
      height: 400px;
      width: 100%;
      margin-bottom: 20px;
    }
    .dark-mode {
      background: #121212;
      color: #eee;
    }
    .dark-mode h1 {
      color: #ff70a6;
    }
    .dark-mode #map {
      filter: invert(0.9) hue-rotate(180deg);
    }
    button {
      margin: 5px 0;
      padding: 6px 12px;
      cursor: pointer;
    }
    #progressBarContainer {
      width: 100%;
      background: #eee;
      height: 10px;
      margin-bottom: 10px;
      border-radius: 5px;
      overflow: hidden;
    }
    #progressBar {
      width: 0%;
      height: 10px;
      background-color: #ff69b4;
      transition: width 0.3s ease;
    }
    ul {
      padding-left: 1em;
    }
  </style>
</head>
<body>
  <button id="toggleDark">üåô Toggle Dark Mode</button>
  <h1>üç¨ Sweet Trip Planner</h1>

  <form id="tripForm">
    <label>
      Start Location: 
      <input type="text" id="start" class="autocomplete" placeholder="e.g. Manchester, UK" required />
    </label><br>
    <label>
      End Location: 
      <input type="text" id="end" class="autocomplete" placeholder="e.g. Liverpool, UK" required />
    </label><br>
    <label>
      Sweets (comma-separated): 
      <input type="text" id="sweets" placeholder="e.g. Haribo, Drumstick, Skittles" required />
    </label><br>
    <button type="submit">Plan My Trip</button>
  </form>

  <div id="map"></div>
  <div id="progressBarContainer">
    <div id="progressBar"></div>
  </div>

  <ul id="sweetStops"></ul>
  <p id="countdown"></p>

  <button onclick="window.print()">üìÑ Save/Print Trip Plan</button>

  <!-- Leaflet JS -->
  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <!-- OpenCage Autocomplete JS -->
  <script src="https://unpkg.com/@opencage/autocomplete-js"></script>

  <script>
    // === API KEYS ===
    const OPENROUTESERVICE_API_KEY = "eyJvcmciOiI1YjNjZTM1OTc4NTExMTAwMDFjZjYyNDgiLCJpZCI6ImZmNTMyZTAyM2FmMjQxYzJiM2UzYTUzMjgzZWU5NjAxIiwiaCI6Im11cm11cjY0In0=;
    const OPENCAGE_API_KEY = "bc76706a624a4bdb9981edb078593495";

    // Elements
    const form = document.getElementById("tripForm");
    const sweetStops = document.getElementById("sweetStops");
    const countdown = document.getElementById("countdown");
    const progressBar = document.getElementById("progressBar");
    const toggleDarkBtn = document.getElementById("toggleDark");

    // Globals
    let map = null;
    let sweetTimers = [];

    // Dark mode toggle
    toggleDarkBtn.addEventListener("click", () => {
      document.body.classList.toggle("dark-mode");
    });

    // Initialize OpenCage Autocomplete
    new OpenCageAutocomplete({
      input: "#start",
      key: OPENCAGE_API_KEY,
      limit: 5
    });
    new OpenCageAutocomplete({
      input: "#end",
      key: OPENCAGE_API_KEY,
      limit: 5
    });

    form.addEventListener("submit", async (e) => {
      e.preventDefault();

      clearTimers();
      sweetStops.innerHTML = "";
      countdown.textContent = "";
      progressBar.style.width = "0%";

      const start = document.getElementById("start").value.trim();
      const end = document.getElementById("end").value.trim();
      const sweetsRaw = document.getElementById("sweets").value.trim();

      if(!start || !end || !sweetsRaw) {
        alert("Please fill all fields!");
        return;
      }

      const sweets = sweetsRaw.split(",").map(s => s.trim()).filter(s => s.length > 0);
      if(sweets.length === 0) {
        alert("Please enter at least one sweet.");
        return;
      }

      try {
        const coords = await getCoordinates([start, end]);
        const route = await getRoute(coords[0], coords[1]);
        displayMap(route.geometry.coordinates, sweets, route.features[0].properties.summary.duration);
      } catch (error) {
        alert("Error fetching route data. Please check your API keys and inputs.");
        console.error(error);
      }
    });

    async function getCoordinates(locations) {
      const results = [];
      for (const location of locations) {
        const res = await fetch(`https://api.openrouteservice.org/geocode/search?api_key=${OPENROUTESERVICE_API_KEY}&text=${encodeURIComponent(location)}`);
        const data = await res.json();
        if(!data.features || data.features.length === 0) {
          throw new Error(`Location not found: ${location}`);
        }
        const [lon, lat] = data.features[0].geometry.coordinates;
        results.push([lon, lat]);
      }
      return results;
    }

    async function getRoute(startCoord, endCoord) {
      const body = {
        coordinates: [startCoord, endCoord]
      };
      const res = await fetch(`https://api.openrouteservice.org/v2/directions/driving-car/geojson`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Authorization": OPENROUTESERVICE_API_KEY
        },
        body: JSON.stringify(body)
      });
      const data = await res.json();
      if(data.features && data.features.length > 0) {
        return data;
      }
      throw new Error("Failed to get route data");
    }

    function displayMap(coords, sweets, durationSeconds) {
      if (map) map.remove();
      map = L.map("map").setView([coords[0][1], coords[0][0]], 10);

      L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png").addTo(map);

      const latlngs = coords.map(([lon, lat]) => [lat, lon]);
      L.polyline(latlngs, { color: "purple" }).addTo(map);

      sweetStops.innerHTML = "";
      countdown.textContent = "";

      const spacing = Math.floor(coords.length / sweets.length);
      const interval = Math.floor(durationSeconds / sweets.length);

      sweets.forEach((sweet, i) => {
        const index = Math.min(spacing * i, coords.length - 1);
        const [lon, lat] = coords[index];
        const marker = L.marker([lat, lon]).addTo(map);
        marker.bindPopup(`üç¨ Time for: ${sweet}`).openPopup();

        const li = document.createElement("li");
        li.textContent = `Eat "${sweet}" at ~${Math.round((i + 1) * interval / 60)} minutes into the trip.`;
        sweetStops.appendChild(li);

        // Schedule countdown timers and progress bar updates
        const timer = setTimeout(() => {
          updateProgress(((i + 1) / sweets.length) * 100);
          countdown.textContent = `‚è∞ Eat "${sweet}" now! (${Math.round((i + 1) * interval / 60)} mins into trip)`;
        }, (i + 1) * interval * 1000);
        sweetTimers.push(timer);
      });

      // Clear countdown after trip ends
      const endTimer = setTimeout(() => {
        countdown.textContent = "üéâ Trip complete! All sweets enjoyed.";
        updateProgress(100);
      }, durationSeconds * 1000);
      sweetTimers.push(endTimer);
    }

    function updateProgress(percent) {
      progressBar.style.width = `${percent}%`;
    }

    function clearTimers() {
      sweetTimers.forEach(t => clearTimeout(t));
      sweetTimers = [];
    }
  </script>
</body>
</html>
