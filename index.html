<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Sweet Trip Planner</title>
  <style>
    body {
      font-family: sans-serif;
      padding: 2rem;
      background: var(--bg, white);
      color: var(--fg, black);
      transition: background 0.3s, color 0.3s;
    }
    .dark {
      --bg: #121212;
      --fg: #f5f5f5;
    }
    input, button, select {
      padding: 0.5rem;
      margin: 0.25rem;
      font-size: 1rem;
    }
    #map {
      height: 300px;
      margin-top: 1rem;
    }
    .sweet-group {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      margin-bottom: 0.5rem;
    }
    .progress-bar {
      height: 20px;
      background: lightgray;
      border-radius: 10px;
      overflow: hidden;
      margin-top: 1rem;
    }
    .progress-bar-inner {
      height: 100%;
      background: #4caf50;
      width: 0%;
      transition: width 0.3s;
    }
  </style>
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@opencage/autocomplete-js@1.10.0/dist/opencage-autocomplete.min.js"></script>
</head>
<body>
  <h1>üç¨ Sweet Trip Planner</h1>
  <label>Start location: <input id="start" type="text"></label><br/>
  <label>End location: <input id="end" type="text"></label><br/>

  <h3>Sweets to bring</h3>
  <div id="sweet-list">
    <div class="sweet-group">
      <input type="text" placeholder="e.g. Haribo" class="sweet-name" />
      <input type="number" value="1" min="1" class="sweet-count" />
      <button onclick="removeSweet(this)">‚àí</button>
    </div>
  </div>
  <button onclick="addSweet()">+ Add Sweet</button>

  <br><br>
  <button onclick="planTrip()">üöó Plan My Trip</button>
  <button onclick="toggleDarkMode()">üåì Toggle Dark Mode</button>
  <button onclick="window.print()">üñ®Ô∏è Save/Print Plan</button>

  <div id="plan-output"></div>
  <div class="progress-bar"><div class="progress-bar-inner" id="progress-bar"></div></div>
  <div id="map"></div>

  <script>
    // Autocomplete setup
    const apiKey = "eyJvcmciOiI1YjNjZTM1OTc4NTExMTAwMDFjZjYyNDgiLCJpZCI6ImZmNTMyZTAyM2FmMjQxYzJiM2UzYTUzMjgzZWU5NjAxIiwiaCI6Im11cm11cjY0In0=";
    new OpenCageAutocomplete({ input: "#start", key: apiKey });
    new OpenCageAutocomplete({ input: "#end", key: apiKey });

    let map;

    function addSweet() {
      const group = document.createElement("div");
      group.className = "sweet-group";
      group.innerHTML = `
        <input type="text" placeholder="e.g. Chocolate" class="sweet-name" />
        <input type="number" value="1" min="1" class="sweet-count" />
        <button onclick="removeSweet(this)">‚àí</button>
      `;
      document.getElementById("sweet-list").appendChild(group);
    }

    function removeSweet(btn) {
      btn.parentElement.remove();
    }

    function toggleDarkMode() {
      document.body.classList.toggle("dark");
    }

    async function geocode(place) {
      const res = await fetch(`https://api.opencagedata.com/geocode/v1/json?q=${encodeURIComponent(place)}&key=${JSON.parse(atob(apiKey)).h}`);
      const data = await res.json();
      return data.results[0]?.geometry;
    }

    async function planTrip() {
      const start = document.getElementById("start").value;
      const end = document.getElementById("end").value;
      const sweetInputs = document.querySelectorAll(".sweet-group");
      const sweets = [];
      sweetInputs.forEach(group => {
        const name = group.querySelector(".sweet-name").value;
        const count = parseInt(group.querySelector(".sweet-count").value);
        if (name && count > 0) sweets.push(...Array(count).fill(name));
      });

      if (!start || !end || sweets.length === 0) {
        alert("Please enter start, end, and at least one sweet.");
        return;
      }

      const startLoc = await geocode(start);
      const endLoc = await geocode(end);
      if (!startLoc || !endLoc) {
        alert("Could not find locations.");
        return;
      }

      const planOutput = document.getElementById("plan-output");
      planOutput.innerHTML = "<h3>Sweet Schedule</h3>";

      // Fake travel time estimate (adjust with real API if desired)
      const durationMinutes = Math.floor(Math.random() * 60 + 30); // 30‚Äì90 mins
      const interval = Math.floor(durationMinutes / sweets.length);

      const ul = document.createElement("ul");
      sweets.forEach((sweet, i) => {
        const li = document.createElement("li");
        li.textContent = `Minute ${i * interval} ‚Üí üç¨ ${sweet}`;
        ul.appendChild(li);
      });
      planOutput.appendChild(ul);
      planOutput.innerHTML += `<p>‚è±Ô∏è Estimated travel time: ${durationMinutes} mins</p>`;

      if (!map) {
        map = L.map('map').setView([startLoc.lat, startLoc.lng], 8);
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png').addTo(map);
      } else {
        map.setView([startLoc.lat, startLoc.lng], 8);
      }

      L.marker([startLoc.lat, startLoc.lng]).addTo(map).bindPopup("üèÅ Start").openPopup();
      L.marker([endLoc.lat, endLoc.lng]).addTo(map).bindPopup("üç≠ End");

      // Animate progress bar
      const progressBar = document.getElementById("progress-bar");
      progressBar.style.width = "0%";
      let pct = 0;
      const intervalID = setInterval(() => {
        pct += 100 / durationMinutes;
        progressBar.style.width = `${Math.min(pct, 100)}%`;
        if (pct >= 100) clearInterval(intervalID);
      }, 1000);
    }
  </script>
</body>
</html>
